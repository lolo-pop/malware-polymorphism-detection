import os
import shutil
import numpy as np
import time
import csv
from numpy import *
import time

funFolder='E:\design\AddedFuncByZhangyunan'
hashbits=128

class simhash:
    def __init__(self, tokens='', hashbits=128):        
        self.hashbits = hashbits
        self.hash = self.simhash(tokens);
    
    def __str__(self):
        return str(self.hash)
     
    def simhash(self, tokens):
        v = [0] * self.hashbits
        for t in [self._string_hash(x) for x in tokens]:     
            for i in range(self.hashbits):
                bitmask = 1 << i
                #print 't: ',t
                if t & bitmask :
                    v[i] += 1
                else:
                    v[i] -= 1
        fingerprint = 0
        for i in range(self.hashbits):
            if v[i] >= 0:
                fingerprint += 1 << i
        return fingerprint
    
    def hamming_distance(self, other):
        x = (self.hash ^ other.hash) & ((1 << self.hashbits) - 1)
        tot = 0;
        while x :
            tot += 1
            x &= x - 1
        return tot
   
    def similarity (self, other):
        a = float(self.hash)
        b = float(other.hash)
        if a > b : return b / a
        else: return a / b
    
    def _string_hash(self, source):        
        if source == "":
            return 0
        else:
            x = ord(source[0]) << 7
            m = 1000003
            mask = 2 ** self.hashbits - 1
            for c in source:
                x = ((x * m) ^ ord(c)) & mask
            x ^= len(source)
            if x == -1:
                x = -2
            return x

def FolderTraverse(targetPath,listAllFiles,listExeOrDll,destPath):
    print ('Traverse target path starting ... ')  
    try: 
        listFile=os.listdir(targetPath)       
        for fileName in listFile:
            print ('fileName: ',fileName)
            filePath=os.path.join(targetPath,fileName)
            if os.path.isdir(filePath):
                FolderTraverse(filePath,listAllFiles,listExeOrDll,destPath)
            else:
                listAllFiles.append(filePath)
                if fileName.split('.')[-1]=='dll' or fileName.split('.')[-1]=='exe' \
                or fileName.split('.')[-1]=='DLL' or fileName.split('.')[-1]=='EXE':
                    listExeOrDll.append(fileName)
                    sourPathToCopy=filePath
                    destPathToCopy=os.path.join(destPath,fileName)
                    shutil.copy(sourPathToCopy,destPathToCopy)  
    except Exception, e:
        print ('Exception: ',e)
    return listAllFiles,listExeOrDll

def ExeAndDllFileMove():
    listAllFiles=[];listExeOrDll=[];listAllFiles1=[];listExeOrDll1=[]
    FolderTraverse('C:\\Program Files',listAllFiles,listExeOrDll,'C:\\LibFiles\\ProgramFiles')
    FolderTraverse('C:\\Windows',listAllFiles1,listExeOrDll1,'C:\\LibFiles\\Windows')
    print ('Done')
    return 0

def LoadData(name):
    #print("start  reading file with target")
    try:
        file=open(name , "r")#r
        listData=[]
        while True:
            line=file.readline().replace("\n","")
            if not line: break
            splits=line.split(";")
            listData.extend(splits)
    finally:
        file.close()
        return listData

def LoadData1(name):
    #print("start  reading file with target")
    try:
        file=open(name , "r")#r
        listData=[]
        while True:
            line=file.readline().replace("\n","")
            if not line: break
            splits=line.split(",")
            listData.append(splits)
    finally:
        file.close()
        return listData

def isRegisterStr(str):
    REG=np.array(["eax","ebx","ecx","edx","esi","edi","esp","ebp","ax","bx","cx","dx","si","di","bp","sp","ah","al","bh","bl","ch","cl","dh","dl"])
    if str in REG:
        return True
    else:
        return False 

def Normalization(targetFile):
    normalizedFunc=[]
    dataInstructions=LoadData(targetFile)
    for instruction in dataInstructions:
        normalizedInstr=[]
        instrOperands=instruction.split(' ')
        normalizedInstr.append(instrOperands[0])
        if len(instrOperands)<=1:
            pass
        else:
            listOperands=instrOperands[1].split(',') 
            for indexOperand in range(len(listOperands)):
                if isRegisterStr(listOperands[indexOperand]):
                    normalizedInstr.append('REG')
                elif "[" in listOperands[indexOperand] \
                or listOperands[indexOperand].startswith("dword") \
                or listOperands[indexOperand].startswith("word"):
                    normalizedInstr.append('MEM')
                elif listOperands[indexOperand].startswith("$") \
                or listOperands[indexOperand].startswith("loc"):
                    normalizedInstr.append('LocAddress')
                elif listOperands[indexOperand].startswith("ds:"):
                    normalizedInstr.append(listOperands[indexOperand].split(':')[1])
                elif listOperands[indexOperand].startswith("offset"):
                    normalizedInstr.append('DataOffset')
                elif listOperands[indexOperand].endswith("h") \
                or listOperands[indexOperand].isdigit():
                    normalizedInstr.append('VAL')
                elif listOperands[indexOperand].startswith("sub"): \
                    normalizedInstr.append('sub_xxxx')
                else:
                    normalizedInstr.append(listOperands[indexOperand])
            normalizedFunc.append(normalizedInstr)
    listNorFuncRet=[]
    '''
    for i in xrange(0, len(normalizedFunc), 2):
        instr1 = normalizedFunc[i]
        if len(instr1)<=2:
            strInstr=instr1[0]+' '+instr1[1]+';'
        else:
            strInstr=instr1[0]+' '+instr1[1]+','+instr1[2]+';'
        if i+1 >= len(normalizedFunc):
            pass
        else:
            instr2 = normalizedFunc[i+1]
            if len(instr2)<=2:
                strInstr+=' '+instr2[0]+' '+instr2[1]
            else:
                strInstr+=' '+instr2[0]+' '+instr2[1]+','+instr2[2]
        listNorFuncRet.append(strInstr) 
    print listNorFuncRet
    '''
    for instr in normalizedFunc:
        if len(instr)<=2:
            strInstr=instr[0]+' '+instr[1]
        else:
            strInstr=instr[0]+' '+instr[1]+','+instr[2]
        listNorFuncRet.append(strInstr) 
    return listNorFuncRet


"""
def simHashCal():
    listNormalizedFunc=Normalization('G:\\FunctionExtraction\\___init_ctype.dsm')
    print listNormalizedFunc
    return 0
"""

###########################################################
def string_hash(source):        
    if source == "":
        return 0
    else:
        x = ord(source[0]) << 7
        m = 1000003
        mask = 2 ** hashbits - 1
        for c in source:
            x = ((x * m) ^ ord(c)) & mask
        x ^= len(source)
        if x == -1:
            x = -2
        return x

def simhashCal(tokens):
    v = [0] * hashbits
    for t in [string_hash(x) for x in tokens]:     
        for i in range(hashbits):
            bitmask = 1 << i
            #print 't: ',t
            if t & bitmask :
                v[i] += 1
            else:
                v[i] -= 1
    """
    fingerprint = 0
    for i in range(hashbits):
        if v[i] >= 0:
            fingerprint += 1 << i
    """
    vReturn = [0] * hashbits
    for i in range(len(v)):
        if v[i]>=0:
            vReturn[i]=1
        else:
            vReturn[i]=0
    return vReturn

def CompareTwoList(sourceList,targetList):
    countEquals=0
    for i in range(len(sourceList)):
        if cmp(sourceList[i],targetList[i])!=0:
            countEquals+=1
    return countEquals
###########################################################

def hamming_distance(sourSimHash, targetSimHash):
    x = (sourSimHash ^ targetSimHash) & ((1 << hashbits) - 1)
    tot = 0;
    while x :
        tot += 1
        x &= x - 1
    return tot

def NormalizedFunc2Gram(listNormalizedFunc):
    listNormalizedFunc2Gram=[]
    for i in range(len(listNormalizedFunc)-1):
        strInstr2Gram=listNormalizedFunc[i]+';'+listNormalizedFunc[i+1]
        listNormalizedFunc2Gram.append(strInstr2Gram)
    return listNormalizedFunc2Gram
    
def SimHashProduce():
    #ExeAndDllFileMove()
    listProgramFilesOrWindows=os.listdir(funFolder)
    countFunc=0
    with open('E:\\design\\LibFilesFuncCSV\\LibFunc_1gram.csv','a+') as f:
        w=csv.writer(f)
        listHeader=['FuncName','BelongExeOrDll','LenOfNormalizedFunc','SimHashSec1','SimHashSec2',
                    'SimHashSec3','SimHashSec4','SimHashSec5','SimHashSec6','SimHashSec7','SimHashSec8','SimHash']
        #w.writerow(listHeader)
        for programFileOrWindows in listProgramFilesOrWindows:
            pFilesOrWinFolderDir=funFolder+os.sep+programFileOrWindows
            listExeOrDllFunFolder=os.listdir(pFilesOrWinFolderDir)
            for exeOrDllFolder in listExeOrDllFunFolder:
                exeOrDllFolderDir=pFilesOrWinFolderDir+os.sep+exeOrDllFolder
                listDsmOrGmlFiles=os.listdir(exeOrDllFolderDir)
                for asmOrGml in listDsmOrGmlFiles:
                    if asmOrGml.split('.')[-1]=='dsm':
                        asmOrGmlDir=exeOrDllFolderDir+os.sep+asmOrGml
                        normalizedFunc=Normalization(asmOrGmlDir)
                        #listNormalizedFunc2Gram=NormalizedFunc2Gram(normalizedFunc)
                        #listFuncSimHash=simhashCal(listNormalizedFunc2Gram)
                        listFuncSimHash=simhashCal(normalizedFunc)
                        arrFuncSimHash=np.array(listFuncSimHash).reshape(8,16)
                        
                        listToWrite=[]
                        listToWrite.append(asmOrGml)
                        listToWrite.append(exeOrDllFolder)
                        #listToWrite.append(len(listNormalizedFunc2Gram))
                        listToWrite.append(len(normalizedFunc))
                        for i in range(len(arrFuncSimHash)):
                            listToWrite.append(''.join([str(e) for e in list(arrFuncSimHash[i])]))
                        listToWrite.append(''.join([str(e) for e in listFuncSimHash]))
                        w.writerow(listToWrite)
                        
                        countFunc+=1                       
                        if countFunc%100==0:
                            print ('Complete: ',countFunc) 
    return 0

def FuncFileFilter():
    baseExeFolder = 'E:\design\\test\sourcesFunction\ConsoleApplication6.exe'
    listDsmAndGmlFiles=os.listdir(baseExeFolder)
    for fileDsmOrGml in listDsmAndGmlFiles:
        #if fileDsmOrGml.split('.')[-1]=='gml':
        #    targetDirGml='G:\\design\\temp'+os.sep+fileDsmOrGml
        #    os.remove(targetDirGml)
        if fileDsmOrGml.split('.')[-1]=='dsm':
            funcDsmFile = open(baseExeFolder+os.sep+fileDsmOrGml, "r")
            countInstr = funcDsmFile.readline().count(";")
            if countInstr<=10:
                funcDsmFile.close()
                targetDsm=baseExeFolder+os.sep+fileDsmOrGml
                targetGml=baseExeFolder+os.sep+fileDsmOrGml.split('.')[0]+'.gml'
                os.remove(targetDsm)
                os.remove(targetGml)
            else:
                funcDsmFile.close()
        elif fileDsmOrGml.split('.')[-1]=='gml':
            funcGmlFile = open(baseExeFolder+os.sep+fileDsmOrGml, "r")
            countTracelet = funcGmlFile.read().count('node')
            if countTracelet < 3:
                funcGmlFile.close()
                targetGml=baseExeFolder+os.sep+fileDsmOrGml
                targetDsm=baseExeFolder+os.sep+fileDsmOrGml.split('.')[0]+'.dsm'
                os.remove(targetDsm)
                os.remvoe(targetGml)
            else:
                funcGmlFile.close()
                os.remove(baseExeFolder+os.sep+fileDsmOrGml)
    return 0

def LibFuncFileFilter():
    baseDir='E:\\design\\FuncLibFiles'
    listBaseFolder=os.listdir(baseDir)
    for baseFolder in listBaseFolder:
        baseFolderDir=baseDir+os.sep+baseFolder
        listExeOrDllFolders=os.listdir(baseFolderDir)
        for exeOrDllFolder in listExeOrDllFolders:                      
            exeOrDllFolderDir=baseFolderDir+os.sep+exeOrDllFolder
            listFuncFiles=os.listdir(exeOrDllFolderDir)
            for funcFile in listFuncFiles:
                funcFileDir=exeOrDllFolderDir+os.sep+funcFile
                print funcFileDir
                if funcFile.split('.')[-1]=='gml':
                    print "this file is going to delete"
                    os.remove(funcFileDir)
            if sum([len(files) for root,dirs,files in os.walk(exeOrDllFolderDir)])==0:
                os.rmdir(exeOrDllFolderDir)
    return 0

def SimilarityCompare():
    baseDir = 'E:\design\\test\sourcesFunction\ConsoleApplication6.exe'
    listSourFuncFiles=os.listdir(baseDir)
    countCompared=0
    startTime=time.time()
    
    listLibFuncSimHashInfoL=LoadData1('E:\\design\\LibFilesFuncCSV\\LibFunc_2gram.csv')
    listLibFuncSimHashInfo=listLibFuncSimHashInfoL[1:len(listLibFuncSimHashInfoL)]
    print listLibFuncSimHashInfo
    exit(0)
    dictFilteredFunc={}
    for funcFile in listSourFuncFiles:
        if funcFile.split('.')[-1]=='dsm':
            funcDsmFileDir=baseDir+os.sep+funcFile#funcFile
            #funcDsmFileDir1='G:\\LibFilesFuncs\\Windows\\wmvdmod.dll'+os.sep+funcFile
            
            normalizedSourceFuncDsm=Normalization(funcDsmFileDir)
            listNormalizedFunc2Gram=NormalizedFunc2Gram(normalizedSourceFuncDsm)
            sourceFileSimHash=simhashCal(listNormalizedFunc2Gram) 
            sourceFileSimHashStr=[str(e) for e in sourceFileSimHash] 
            arrSourceFileSimHash=np.array(sourceFileSimHash).reshape(8,16)            
            listSourceFileSimHashSec=[]
            for i in range(len(arrSourceFileSimHash)):
                listSourceFileSimHashSec.append(''.join([str(e) for e in list(arrSourceFileSimHash[i])]))
                            
            listLibFuncCandidate=[]
            for singleLibFuncSimHashInfo in listLibFuncSimHashInfo:
                countSec=0
                for i in range(len(listSourceFileSimHashSec)):
                    if cmp(listSourceFileSimHashSec[i],singleLibFuncSimHashInfo[i+3])==0:
                        countSec+=1
                if countSec>=4:
                    listLibFuncCandidate.append(singleLibFuncSimHashInfo)            
            
            for singleFuncInCandidate in listLibFuncCandidate:
                hammingDistance=CompareTwoList(sourceFileSimHashStr, list(singleFuncInCandidate[11]))
                if hammingDistance<=4 and abs(len(normalizedSourceFuncDsm)-int(singleFuncInCandidate[2]))<=10:
                    if funcFile in dictFilteredFunc.keys():
                        dictFilteredFunc[funcFile]+=1
                    else:
                        dictFilteredFunc[funcFile]=1
                    print 'Source func:',funcFile,': ','Target func: ',singleFuncInCandidate[0],': ',singleFuncInCandidate[1],': ',singleFuncInCandidate[2]
                    pass
        else:
            print 'an gml file ... ... #####################'               
        countCompared+=1
        print ('Complete one file compare',funcFile,countCompared)
        print ('############################################')    
    elapsedTime=time.time()-startTime
    print 'Time elapsed for similarity compare: ',elapsedTime
    print 'Count of filtered func: ',len(dictFilteredFunc.keys())
    print 'Filtered func: ',dictFilteredFunc
    return 0

def SimilarityCompareTest():
    listSimHashData=LoadData1('G:\\LibFilesFuncCSV\\LibFunc.csv')
    listLibSimHash=listSimHashData[1:len(listSimHashData)]
    
    listSourFuncFiles=os.listdir('G:\\design\\temp')
    countCompared=0
    for funcFile in listSourFuncFiles:
        if funcFile.split('.')[-1]=='dsm':
            funcDsmFileDir='G:\\simHashTest'+os.sep+'sub_40CB00.dsm'#funcFile
            funcDsmFileDir1='G:\\simHashTest'+os.sep+'sub_40CB001.dsm'#funcFile
            
            normalizedFuncDsm=Normalization(funcDsmFileDir)
            #print 'normalizedFuncDsm: ',normalizedFuncDsm
            normalizedFuncDsm1=Normalization(funcDsmFileDir1)
            
            listNormalizedFunc2Gram=NormalizedFunc2Gram(normalizedFuncDsm)
            listNormalizedFunc2Gram1=NormalizedFunc2Gram(normalizedFuncDsm1)

            funcNorDsmFileSimHash=simhashCal(listNormalizedFunc2Gram)  
            funcNorDsmFileSimHash1=simhashCal(listNormalizedFunc2Gram1)

            for libHash in listLibSimHash:
                hammingDistance=hamming_distance(funcNorDsmFileSimHash,funcNorDsmFileSimHash1)
                print ('hammingDistance: ',hammingDistance)
                if hammingDistance<=4:
                    print ('find one: ',funcFile,libHash[1],libHash[2])
                    print (hammingDistance)
                exit(0)
        countCompared+=1
        print ('############################################')            
        print ('Complete one file compare',funcFile,countCompared)
    return 0

def main():
    #ExeAndDllFileMove()
    #LibFuncFileFilter()
    SimHashProduce()
    
    #FuncFileFilter()
    #SimilarityCompare()
    #SimilarityCompareTest()
    return 0


if __name__=="__main__":
    main()













































