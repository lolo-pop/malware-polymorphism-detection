# -*- coding:utf-8 -*- 
"""
Author: hyt
"""
import random
import math
import os,sys
from functools import cmp_to_key
from struct import pack,unpack
import time

class groupCompare:
    def __init__(self,mask):
        self.mask=mask
    def cmp(self,a,b):
        return (a & self.mask) - (b & self.mask)
        # return 1 if self.__cmp(a,b) else -1 if self.__cmp(b,a) else 0
    def __cmp(self,a,b):
        return (a & self.mask) > (b & self.mask) or (a & self.mask) == (b & self.mask) and (a & ~self.mask) > (b & ~self.mask)
    def maincmp(self,a,b):
        return (a & self.mask) - (b & self.mask)

def masksGen():
    res=[]
    for i in range(0,4):
        outMask=0xffff<<i*16
        for j in range(0,4):
            tmp=0xfff<<j*12
            inMask=tmp & ((1<<i*16)-1) | ((tmp << 16) & ~((1<<i*16+16)-1))
            res.append((outMask | inMask) & 0xffffffffffffffff)
    print ('res: ',res)
    print ('len: ',len(res))
    exit(0)
    return res

def hamming(a,b):
    diff=a^b
    diff = (diff&0x5555555555555555) + ((diff>>1)&0x5555555555555555); 
    diff = (diff&0x3333333333333333) + ((diff>>2)&0x3333333333333333); 
    diff = (diff&0x0f0f0f0f0f0f0f0f) + ((diff>>4)&0x0f0f0f0f0f0f0f0f); 
    diff = (diff&0x00ff00ff00ff00ff) + ((diff>>8)&0x00ff00ff00ff00ff); 
    diff = (diff&0x0000ffff0000ffff) + ((diff>>16)&0x0000ffff0000ffff);
    diff = (diff&0x00000000ffffffff) + ((diff>>32)&0x00000000ffffffff);
    return diff

def bisect_right(a, x, cmp,lo=0, hi=None):
    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if cmp(x,a[mid])<0 : hi = mid
        else: lo = mid+1
    return lo

def bisect_left(a, x, cmp,lo=0, hi=None):
    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2 
        if cmp(a[mid],x)<0 : lo = mid+1
        else: hi = mid
    return lo

def sortedHashsRead(masks):
    sortedHashs=[]
    with open("sortedHashs.dat","rb") as fin:
        quan=unpack("Q",fin.read(8))[0]
        for i in range(0,len(masks)):
            tmp=[]  
            for j in range(0,quan):
                tmp.append(unpack("Q",fin.read(8))[0])
            sortedHashs.append(tmp)
    return sortedHashs

def sortedHashsWrite(sortedHashs):
    with open("sortedHashs.dat","wb") as fout:
        fout.write(pack("Q",len(sortedHashs[0])))
        for group in sortedHashs:
            for hashh in group:
                fout.write(pack("Q",hashh))

def sortedHashsGen(masks):
    hashs=[]
    with open("G:\LibFilesFuncCSV\hashs.dat",'r') as fin:
        while True:
            line=fin.readline()
            if not line:
                break;
            hashs.append(int(line))
    sortedHashs=[]
    print("%d hashs got."% len(hashs))
    for i in range(0,len(masks)):
        sortedHashs.append(sorted(hashs,key=cmp_to_key(groupCompare(masks[i]).cmp)))
        print("%d mask-sorted." % (i+1))
    print("hashs generated.")
    return sortedHashs

def query(sample):
    res=set()
    for index,sd in enumerate(sortedHashs):
        left=bisect_left(sd,sample,groupCompare(masks[index]).maincmp)
        right=bisect_right(sd,sample,groupCompare(masks[index]).maincmp)
        for i in range(left,right):
            if hamming(sample,sd[i])<=3: 
                res.add(sd[i])
    return res

def loadDatas():
    global sortedHashs
    sortedHashs=sortedHashsRead(masks)

def genDatas():
    sortedHashs=sortedHashsGen(masks)
    sortedHashsWrite(sortedHashs)

sortedHashs=[]
masks=masksGen()

if __name__ == '__main__':
    genDatas()
    """
    if len(sys.argv)==1:
        loadDatas()
        start=time.clock()
        for sample in random.sample(sortedHashs[0], 1000):
            res=query(sample)
        print(time.clock()-start)
    elif sys.argv[2]=='generate':
        genDatas()
    """


#=========================TEST====================================
# masks=masksGen()
# print(groupCompare(masks[0]).maincmp(0x1fffffff,0x2fffffff))
