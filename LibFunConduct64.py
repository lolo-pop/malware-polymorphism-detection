import os
import shutil
import numpy as np
#import pandas as pd
import time
import csv
from numpy import *
import time
import string


funFolder='E:\design\FuncLibFiles'
hashbits=64

class simhash:
    def __init__(self, tokens='', hashbits=128):        
        self.hashbits = hashbits
        self.hash = self.simhash(tokens);
    
    def __str__(self):
        return str(self.hash)
     
    def simhash(self, tokens):
        v = [0] * self.hashbits
        for t in [self._string_hash(x) for x in tokens]:     
            for i in range(self.hashbits):
                bitmask = 1 << i
                #print 't: ',t
                if t & bitmask :
                    v[i] += 1
                else:
                    v[i] -= 1
        fingerprint = 0
        for i in range(self.hashbits):
            if v[i] >= 0:
                fingerprint += 1 << i
        return fingerprint
    
    def hamming_distance(self, other):
        x = (self.hash ^ other.hash) & ((1 << self.hashbits) - 1)
        tot = 0;
        while x :
            tot += 1
            x &= x - 1
        return tot
   
    def similarity (self, other):
        a = float(self.hash)
        b = float(other.hash)
        if a > b : return b / a
        else: return a / b
    
    def _string_hash(self, source):        
        if source == "":
            return 0
        else:
            x = ord(source[0]) << 7
            m = 1000003
            mask = 2 ** self.hashbits - 1
            for c in source:
                x = ((x * m) ^ ord(c)) & mask
            x ^= len(source)
            if x == -1:
                x = -2
            return x

"""
def FolderTraverse(targetPath,listAllFiles,listExeOrDll,destPath):
    print ('Traverse target path starting ... ')  
    try: 
        listFile=os.listdir(targetPath)       
        for fileName in listFile:
            print ('fileName: ',fileName)
            filePath=os.path.join(targetPath,fileName)
            if os.path.isdir(filePath):
                FolderTraverse(filePath,listAllFiles,listExeOrDll,destPath)
            else:
                listAllFiles.append(filePath)
                if fileName.split('.')[-1]=='dll' or fileName.split('.')[-1]=='exe' \
                or fileName.split('.')[-1]=='DLL' or fileName.split('.')[-1]=='EXE':
                    listExeOrDll.append(fileName)
                    sourPathToCopy=filePath
                    destPathToCopy=os.path.join(destPath,fileName)
                    shutil.copy(sourPathToCopy,destPathToCopy)  
    except Exception, e:
        print ('Exception: ',e)
    return listAllFiles,listExeOrDll
"""

def ExeAndDllFileMove():
    listAllFiles=[];listExeOrDll=[];listAllFiles1=[];listExeOrDll1=[]
    FolderTraverse('C:\\Program Files',listAllFiles,listExeOrDll,'G:\\LibFiles\\ProgramFiles')
    FolderTraverse('C:\\Windows',listAllFiles1,listExeOrDll1,'G:\\LibFiles\\Windows')
    print ('Done')
    return 0

def LoadData(name):
    #print("start  reading file with target")
    try:
        file=open(name , "r")#r
        listData=[]
        while True:
            line=file.readline().replace("\n","")
            if not line: break
            splits=line.split(";")
            listData.extend(splits)
    finally:
        file.close()
        return listData

def LoadData1(name):
    #print("start  reading file with target")
    try:
        file=open(name , "r")#r
        listData=[]
        while True:
            line=file.readline().replace("\n","")
            if not line: break
            splits=line.split(",")
            listData.append(splits)
    finally:
        file.close()
        return listData

def isRegisterStr(str):
    REG=np.array(["eax","ebx","ecx","edx","esi","edi","esp","ebp","ax","bx","cx","dx","si","di","bp","sp","ah","al","bh","bl","ch","cl","dh","dl"])
    if str in REG:
        return True
    else:
        return False 

def Normalization(targetFile):
    normalizedFunc=[]
    dataInstructions=LoadData(targetFile)
    for instruction in dataInstructions:
        normalizedInstr=[]
        instrOperands=instruction.split(' ')
        if instrOperands[0]=='call':
            #print instruction
            normalizedInstr.append(instrOperands[0])
            normalizedFunc.append(normalizedInstr)
        else:
            normalizedInstr.append(instrOperands[0])
            if len(instrOperands)<=1:
                pass
            else:
                listOperands=instrOperands[1].split(',') 
                for indexOperand in range(len(listOperands)):
                    if isRegisterStr(listOperands[indexOperand]):
                        normalizedInstr.append('REG')
                    elif "[" in listOperands[indexOperand]:
                        normalizedInstr.append('MEM')
                    elif "loc" in listOperands[indexOperand].split('_') or listOperands[indexOperand].startswith("$"):
                        normalizedInstr.append('LocAddress')
                    elif "ds:" in listOperands[indexOperand]:
                        #print listOperands[indexOperand]
                        operandsAPI=listOperands[indexOperand].split(":")[1].split('@')[0]
                        normalizedInstr.append(listOperands[indexOperand].split(':')[0]+':'+operandsAPI)
                    elif "offset" in listOperands[indexOperand].split(' '):
                        normalizedInstr.append('DataOffset')
                    elif listOperands[indexOperand].endswith("h") or listOperands[indexOperand].isdigit():
                        normalizedInstr.append('VAL')
                    elif "sub" in listOperands[indexOperand].split('_'):
                        normalizedInstr.append('sub_xxxx')
                    elif "___security_cookie" in listOperands[indexOperand]:
                        normalizedInstr.append('WinAPI')
                    elif 'dword' in listOperands[indexOperand].split(' ') or 'word' in listOperands[indexOperand].split(' '):
                        normalizedInstr.append('MEM')
                        #print listOperands[indexOperand]
                    elif 'off' in listOperands[indexOperand].split('_'):
                        normalizedInstr.append('MEM')
                    elif 'dword' in listOperands[indexOperand].split('_') or 'word' in listOperands[indexOperand].split('_'):
                        normalizedInstr.append('MEM')
                    elif 'locret' in listOperands[indexOperand].split('_'):
                        normalizedInstr.append('LocRet')
                    elif listOperands[indexOperand].startswith("?"):
                        normalizedInstr.append('WinAPI')
                    else:
                        normalizedInstr.append(listOperands[indexOperand])
                normalizedFunc.append(normalizedInstr)    
    listNorFuncRet=[]
    for instr in normalizedFunc:
        if len(instr)<=1:
            strInstr=instr[0]
        elif len(instr)==2:
            strInstr=instr[0]+' '+instr[1]
        else:
            strInstr=instr[0]+' '+instr[1]+','+instr[2]
        listNorFuncRet.append(strInstr) 
    #if 'call' in listNorFuncRet:
        #print listNorFuncRet
    return listNorFuncRet


"""
def simHashCal():
    listNormalizedFunc=Normalization('G:\\FunctionExtraction\\___init_ctype.dsm')
    print listNormalizedFunc
    return 0
"""

###########################################################
def string_hash(source):        
    if source == "":
        return 0
    else:
        x = ord(source[0]) << 7
        m = 1000003
        mask = 2 ** hashbits - 1
        for c in source:
            x = ((x * m) ^ ord(c)) & mask
        x ^= len(source)
        if x == -1:
            x = -2
        return x

def simhashCal(tokens):
    v = [0] * hashbits
    for t in [string_hash(x) for x in tokens]:  
        for i in range(hashbits):
            bitmask = 1 << i
            if t & bitmask :
                v[i] += 1
            else:
                v[i] -= 1
    """
    fingerprint = 0
    for i in range(hashbits):
        if v[i] >= 0:
            fingerprint += 1 << i
    """
    vReturn = [0] * hashbits
    for i in range(len(v)):
        if v[i]>=0:
            vReturn[i]=1
        else:
            vReturn[i]=0
    return vReturn

def CompareTwoList(sourceList,targetList):
    countEquals=0
    for i in range(len(sourceList)):
        if cmp(sourceList[i],targetList[i])!=0:
            countEquals+=1
    return countEquals
###########################################################

def hamming_distance(sourSimHash, targetSimHash):
    x = (sourSimHash ^ targetSimHash) & ((1 << hashbits) - 1)
    tot = 0;
    while x :
        tot += 1
        x &= x - 1
    return tot
hashbits1=16
def hamming_distance1(sourSimHash, targetSimHash):
    x = (sourSimHash ^ targetSimHash) & ((1 << hashbits1) - 1)
    tot = 0;
    while x :
        tot += 1
        x &= x - 1
    return tot

def NormalizedFunc2Gram(listNormalizedFunc):
    listNormalizedFunc2Gram=[]
    for i in range(len(listNormalizedFunc)-1):
        strInstr2Gram=listNormalizedFunc[i]+'/'+listNormalizedFunc[i+1]
        listNormalizedFunc2Gram.append(strInstr2Gram)
    return listNormalizedFunc2Gram
    
def SimHashProduce():
    #ExeAndDllFileMove()
    listProgramFilesOrWindows=os.listdir(funFolder)
    countFunc=0
    with open('E:\\design\\LibFilesFuncCSV\\LibFunc.csv','wb') as f:
        w=csv.writer(f)
        listHeader=['FuncName','BelongExeOrDll','LenOfNormalizedFunc','SimHashSec1','SimHashSec2',
                    'SimHashSec3','SimHashSec4','SimHash']
        w.writerow(listHeader)
        for programFileOrWindows in listProgramFilesOrWindows:
            pFilesOrWinFolderDir=funFolder+os.sep+programFileOrWindows
            listExeOrDllFunFolder=os.listdir(pFilesOrWinFolderDir)
            for exeOrDllFolder in listExeOrDllFunFolder:
                exeOrDllFolderDir=pFilesOrWinFolderDir+os.sep+exeOrDllFolder
                listDsmOrGmlFiles=os.listdir(exeOrDllFolderDir)
                for asmOrGml in listDsmOrGmlFiles:
                    if asmOrGml.split('.')[-1]=='dsm':
                        asmOrGmlDir=exeOrDllFolderDir+os.sep+asmOrGml
                        normalizedFunc=Normalization(asmOrGmlDir)
                        
                        listFuncSimHash=simhashCal(normalizedFunc)
                        arrFuncSimHash=np.array(listFuncSimHash).reshape(4,16)
                        
                        listToWrite=[]
                        listToWrite.append(asmOrGml)
                        listToWrite.append(exeOrDllFolder)
                        listToWrite.append(len(normalizedFunc))
                        for i in range(len(arrFuncSimHash)):
                            listToWrite.append(''.join([str(e) for e in list(arrFuncSimHash[i])]))
                        listToWrite.append(''.join([str(e) for e in listFuncSimHash]))
                        w.writerow(listToWrite)
                        
                        countFunc+=1                       
                        if countFunc%100==0:
                            print ('Complete: ',countFunc) 
    return 0

def FuncFileFilter():
    listDsmFiles=os.listdir('G:\\Paper3ExperimentNew\\temp')

    for fileDsm in listDsmFiles:
        #if fileDsmOrGml.split('.')[-1]=='gml':
        #    targetDirGml='G:\\Paper3ExperimentNew\\temp'+os.sep+fileDsmOrGml
        #    os.remove(targetDirGml)
        if fileDsm.split('.')[-1]=='dsm':
            funcDsmFile = open('G:\\Paper3ExperimentNew\\temp'+os.sep+fileDsm, "r")
            countInstr = funcDsmFile.readline().count(";")
            if countInstr<=15:
                funcDsmFile.close()
                targetDsm='G:\\Paper3ExperimentNew\\temp'+os.sep+fileDsm
                targetGml='G:\\Paper3ExperimentNew\\temp'+os.sep+fileDsm.split('.')[0]+'.gml'
                os.remove(targetDsm)
                os.remove(targetGml)

    listGmlFiles=os.listdir('G:\\Paper3ExperimentNew\\temp')
    for fileGml in listGmlFiles:            
        if fileGml.split('.')[-1]=='gml':
            funcGmlFile=open('G:\\Paper3ExperimentNew\\temp'+os.sep+fileGml, "r")
            countNode=funcGmlFile.read().count("node")
            if countNode<=3:
                funcGmlFile.close()
                targetGmlDir='G:\\Paper3ExperimentNew\\temp'+os.sep+fileGml
                targetDsmDir='G:\\Paper3ExperimentNew\\temp'+os.sep+fileGml.split('.')[0]+'.dsm'
                os.remove(targetGmlDir)
                os.remove(targetDsmDir)
    return 0

def LibFuncFileFilter():
    baseDir='G:\\LibFilesFuncs'
    listBaseFolder=os.listdir(baseDir)
    for baseFolder in listBaseFolder:
        baseFolderDir=baseDir+os.sep+baseFolder
        listExeOrDllFolders=os.listdir(baseFolderDir)
        for exeOrDllFolder in listExeOrDllFolders:                      
            exeOrDllFolderDir=baseFolderDir+os.sep+exeOrDllFolder
            listFuncFiles=os.listdir(exeOrDllFolderDir)
            for funcFile in listFuncFiles:
                funcFileDir=exeOrDllFolderDir+os.sep+funcFile
                if funcFile.split('.')[-1]=='gml':
                    os.remove(funcFileDir)
                else:
                    funcDsmFile = open(funcFileDir, "r")
                    countInstr = funcDsmFile.readline().count(";")
                    if countInstr<=10:
                        funcDsmFile.close()
                        os.remove(funcFileDir)
                        
            if sum([len(files) for root,dirs,files in os.walk(exeOrDllFolderDir)])==0:
                os.rmdir(exeOrDllFolderDir)
    return 0

def SimilarityCompare():
    listSourFuncFiles=os.listdir('G:\\Paper3ExperimentNew\\temp')
    countCompared=0
    startTime=time.time()
    
    listLibFuncSimHashInfoL=LoadData1('G:\\LibFilesFuncCSV\\LibFunc_1gram.csv')
    listLibFuncSimHashInfo=listLibFuncSimHashInfoL[1:len(listLibFuncSimHashInfoL)]
    
    dictFilteredFunc={}
    for funcFile in listSourFuncFiles:
        if funcFile.split('.')[-1]=='dsm':
            startTime1=time.time()
            funcDsmFileDir='G:\\Paper3ExperimentNew\\temp'+os.sep+funcFile#funcFile
            
            normalizedSourceFuncDsm=Normalization(funcDsmFileDir)
            sourceFileSimHash=simhashCal(normalizedSourceFuncDsm)
            #print 'sourceFileSimHash: ',sourceFileSimHash
            sourceFileSimHashStr=[str(e) for e in sourceFileSimHash] 
                    
            arrSourceFileSimHash=np.array(sourceFileSimHash).reshape(8,16)            
            listSourceFileSimHashSec=[]
            for i in range(len(arrSourceFileSimHash)):
                listSourceFileSimHashSec.append(''.join([str(e) for e in list(arrSourceFileSimHash[i])]))
            timeElapsed1=time.time()-startTime1
            #print ('len of listSourceFileSimHashSec: ',listSourceFileSimHashSec)
            startTime2=time.time()                
            listLibFuncCandidate=[]
            count=0
            for singleLibFuncSimHashInfo in listLibFuncSimHashInfo:
                countEqualSec=0
                countNotEqualSec=0
                for i in range(len(listSourceFileSimHashSec)):
                    if listSourceFileSimHashSec[i]==singleLibFuncSimHashInfo[i+3]: countEqualSec+=1
                    else: countNotEqualSec+=1
                    if countNotEqualSec>1: break
                    if countEqualSec>6:
                        listLibFuncCandidate.append(singleLibFuncSimHashInfo)
                        break
                
            #print ('listLibFuncCndidate: ',listLibFuncCandidate)    
            #print ('len of listLibFuncCandidate: ',len(listLibFuncCandidate))
            timeElapsed2=time.time()-startTime2          
            
            startTime3=time.time() 
            for singleFuncInCandidate in listLibFuncCandidate:
                hammingDistance=CompareTwoList(np.array(sourceFileSimHashStr), np.array(list(singleFuncInCandidate[11])))
                if hammingDistance<=7 and abs(len(normalizedSourceFuncDsm)-int(singleFuncInCandidate[2]))<=10:
                    if funcFile in dictFilteredFunc.keys():
                        dictFilteredFunc[funcFile]+=1
                    else:
                        dictFilteredFunc[funcFile]=1
                    print ('Source func:',funcFile,': ','Target func: ',singleFuncInCandidate[0],': ',singleFuncInCandidate[1],': ',singleFuncInCandidate[2])
                    pass
            timeElapsed3=time.time()-startTime3
            print (timeElapsed1)
            print ('timeElapsed2: ',timeElapsed2)
            print (timeElapsed3)
        else:
            print ('an gml file ... ... ... ... ... ... ...')               
        countCompared+=1
        print ('Complete one file compare',funcFile,countCompared)
        print ('############################################')    
    elapsedTime=time.time()-startTime
    print ('Time elapsed for similarity compare: ',elapsedTime)
    print ('Count of filtered func: ',len(dictFilteredFunc.keys()))
    print ('Filtered func: ',dictFilteredFunc)
    return 0

def SimilarityCompareTest():
    listSimHashData=LoadData1('G:\\LibFilesFuncCSV\\LibFunc.csv')
    listLibSimHash=listSimHashData[1:len(listSimHashData)]
    
    listSourFuncFiles=os.listdir('G:\\Paper3ExperimentNew\\temp')
    countCompared=0
    for funcFile in listSourFuncFiles:
        if funcFile.split('.')[-1]=='dsm':
            funcDsmFileDir='G:\\simHashTest'+os.sep+'sub_40CB00.dsm'#funcFile
            funcDsmFileDir1='G:\\simHashTest'+os.sep+'sub_40CB001.dsm'#funcFile
            
            normalizedFuncDsm=Normalization(funcDsmFileDir)
            #print 'normalizedFuncDsm: ',normalizedFuncDsm
            normalizedFuncDsm1=Normalization(funcDsmFileDir1)
            
            listNormalizedFunc2Gram=NormalizedFunc2Gram(normalizedFuncDsm)
            listNormalizedFunc2Gram1=NormalizedFunc2Gram(normalizedFuncDsm1)

            funcNorDsmFileSimHash=simhashCal(listNormalizedFunc2Gram)  
            funcNorDsmFileSimHash1=simhashCal(listNormalizedFunc2Gram1)

            for libHash in listLibSimHash:
                hammingDistance=hamming_distance(funcNorDsmFileSimHash,funcNorDsmFileSimHash1)
                print ('hammingDistance: ',hammingDistance)
                if hammingDistance<=4:
                    print ('find one: ',funcFile,libHash[1],libHash[2])
                    print (hammingDistance)
                exit(0)
        countCompared+=1
        print ('############################################')            
        print ('Complete one file compare',funcFile,countCompared)
    return 0

def main():
    #ExeAndDllFileMove()
    #LibFuncFileFilter()
    SimHashProduce()
    
    #FuncFileFilter()
    #SimilarityCompare()
    #SimilarityCompareTest()
    return 0


if __name__=="__main__":
    main()













































